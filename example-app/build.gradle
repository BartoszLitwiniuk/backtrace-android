apply plugin: 'com.android.application'


class BacktracePluginExtension {
    String url = 'https://backtrace.io/'
    String token = null
    String uuid = null
    String universe = null
    String format = "proguard"
    String manifestPath = null
    String mappingFilePath = null
    boolean autoUpload = false
    boolean overwriteIdentifier = true
    boolean overwriteMappingFile = true
}

class BacktracePlugin implements Plugin<Project> {
    void apply(Project project) {
        // Add the 'greeting' extension object
        def extension = project.extensions.create('backtraceExtension', BacktracePluginExtension)
        // Add a task that uses configuration from the extension object
        project.task('backtrace') {
            doLast {
                println extension.url
                println extension.token
            }
        }

        project.task('generateBuildIdentifier') {

        }




        project.task('printMappingFile') {
//            def manifest = new XmlSlurper().parse(file("AndroidManifest.xml"))

// returns "com.exmaple.your.app"
//            println manifest.@package.text()
            project.android.applicationVariants.all { variant ->

                // printing the name of each variant
                println variant.name

                // checking for mapping file and printing the absolute path
                if (variant.mappingFile != null && variant.mappingFile.exists()) {
                    println variant.mappingFile.absolutePath
                }
                variant.outputs.each { output ->
//                    def manifestDir = output.processManifest.manifestOutputDirectory
//                    def srcManifestFile = "$manifestDir/AndroidManifest.xml"
                    def buildIdentifier = generateUUID() // TODO: handle passed from parameters

//                    modifyManifestFile(srcManifestFile, buildIdentifier)
//                    TODO: uncomment
                    output.processManifest.doLast {
                        def manifestDir = output.processManifest.manifestOutputDirectory
                        println manifestDir
                        def srcManifestFile = "$manifestDir/AndroidManifest.xml"
                        modifyManifestFile(srcManifestFile, buildIdentifier)
                        println "modifyManifestFile - Done"
                        uploadMapping(url, buildIdentifier, srcManifestFile)
                        println "uploadMapping - Done"
                    }



//                    def processorTask = output.processManifestProvider.getOrNull()
//                    processorTask.doLast { task ->
//                        def directory = task.getBundleManifestOutputDirectory()
//                        println directory
////                        def srcManifestFile = "$directory/AndroidManifest.xml"
////                        def manifestContent = new File(srcManifestFile).getText()
////                        def xml = new XmlParser(false, false).parseText(manifestContent)
////
////                        xml.application[0].appendNode("meta-data", ['android:name': 'channelId', 'android:value': '\\' + channelId])
////
////                        def serializeContent = groovy.xml.XmlUtil.serialize(xml)
////                        def buildType = getPluginBuildType(project)
////                        new File("${project.buildDir}/intermediates/merged_manifests/$buildType/AndroidManifest.xml").write(serializeContent)
//                    }
//                }
                }
            }
        }
    }

    static void modifyManifestFile(String manifestPath, String buildIdentifier){
        println manifestPath
        def metaDataIdentifier = "backtraceBuildIdentifier"
        def manifestContent = new File(manifestPath).getText()
        def xml = new XmlParser(false, false).parseText(manifestContent)

        def buildIdentifierExists = !xml.application[0]["meta-data"]["@android:name=$metaDataIdentifier"].isEmpty()
        if (buildIdentifierExists){ // TODO: add if exists and overwrite
            def node = xml.application[0]["meta-data"].find()
            def parent = node.parent()
            parent.remove(node)
            println "Identifier exists"
        }

        xml.application[0].appendNode("meta-data", ['android:name': metaDataIdentifier, 'android:value': buildIdentifier])
        def serializeContent = groovy.xml.XmlUtil.serialize(xml)
        new File(manifestPath).write(serializeContent)
        println "Modifying manifest file complete!"
    }

    static String generateUUID(){
        def id = UUID.randomUUID().toString()
        println "Generated identifier: ${id}"
        return id
    }

    static void uploadMapping(url, uuid, mappingFilePath){
        println "Start uploading mapping.."
        url = "${url}post?format=android-library&symbolication_id=" + uuid
        url = "${url}post?format=proguard&symbolication_id=${uuid}&token=5be39ab2da5c4a250119dee01b3c3c1b61d2c8ea61a48e946902afe16620723d&universe=yolo&project=android-library"
        println url
            if (mappingFilePath != null && !mappingFilePath.isEmpty()) {
                File file = new File(mappingFilePath)
                println mappingFilePath
                // TODO: Add check if file exists

                def post = new URL(url).openConnection();
                post.setRequestMethod("POST")
                post.setDoOutput(true)
                post.setRequestProperty("Content-Type", "application/json")
                post.getOutputStream().write(file.getBytes())
                println("Sending request..")
                def postRC = post.getResponseCode()
                println("Response..")

                println(postRC);
                if(postRC.equals(200)) {
                    println(post.getInputStream().getText());
                }
                else{
                    println(post.getErrorStream().getText())
                }
            }
    }
}


// Configure the extension
//backtrace {
//}
///////////////////////////////////////////////////////


android {
    compileSdkVersion 28
    defaultConfig {
        applicationId "backtraceio.backtraceio"
        minSdkVersion 19
        targetSdkVersion 28
        versionCode 1
        versionName "1.0"
        buildToolsVersion "28.0.2"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
    }
    buildTypes {
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
    buildToolsVersion '28.0.3'
    apply plugin: BacktracePlugin

}

dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    implementation 'com.android.support:appcompat-v7:28.0.0'
    implementation 'com.android.support.constraint:constraint-layout:1.1.3'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:1.0.2'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
    implementation project(':backtrace-library')
}
