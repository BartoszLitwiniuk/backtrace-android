apply plugin: 'com.android.application'


class BacktracePluginExtension {
    String url = 'https://backtrace.io/'
    String token
    String uuid
    String universe
    String projectName
    String format = "proguard"
    String manifestPath
    String mappingFilePath
    boolean autoUpload
    boolean overwriteIdentifier = true
    boolean overwriteMappingFile = true
}

class BacktracePlugin implements Plugin<Project> {
    void apply(Project project) {
        BacktracePluginExtension extension = project.extensions.create('backtrace', BacktracePluginExtension)
        project.android.applicationVariants.all { variant ->
            println variant.name

            variant.outputs.each { output ->
                println 'A'
                println output
//                println variant.mappingFile.absolutePath

//                println variant.mappingFile
                println 'B'
                def buildIdentifier = validateBuildIdentifier(extension.uuid) ? extension.uuid : generateBuildIdentifier()

                output.processManifest.doFirst {
                    def srcManifestFile = "$output.processManifest.manifestOutputDirectory/AndroidManifest.xml"
                    removeMergedManifest(srcManifestFile)
                }
                output.processManifest.doLast {
                    def srcManifestFile = "$output.processManifest.manifestOutputDirectory/AndroidManifest.xml"
                    modifyManifestFile(srcManifestFile, buildIdentifier)
                }

                variant.assemble.doLast {
                    if ( variant.mappingFile != null &&
                            variant.mappingFile.exists() ) {
                        println 'there is mapping file!'
                        println variant.mappingFile.absolutePath
                    }
                    else {
                        println 'mapping file doesnt exist'
                    }
                    println "Hello World! End. ${variant.name}"
                }
//                tasks.register("hello") {
//                    doLast {
//                        println 'Hello, World!'
//                        println buildIdentifier
//                    }
//                }
            }
        }
    }

    static void removeMergedManifest(String path){
        println 'REMOVE MERGED MANIFEST'
        File file = new File(path)
        if (file.exists()){
            println 'Manifest file already exists'
            file.delete()
        }
        else {
            println 'Manifest file doesn\'t exists'
        }
    }

    static validateBuildIdentifier(String passedUUID){
//        Add validation
        return false
    }

    static String generateBuildIdentifier(){
        def id = UUID.randomUUID().toString()
        println "Generated identifier: ${id}"
        return id
    }


    static void modifyManifestFile(String manifestFilePath, String buildIdentifier){
        println manifestFilePath
        def metaDataIdentifier = "backtrace.io.build.id"
        def manifestContent = new File(manifestFilePath).getText()
        def xml = new XmlParser(false, false).parseText(manifestContent)

        def buildIdentifierExists = !xml.application[0]["meta-data"]["@android:name=$metaDataIdentifier"].isEmpty()
        if (buildIdentifierExists){ // TODO: add if exists and overwrite
            def node = xml.application[0]["meta-data"].find()
            def parent = node.parent()
            parent.remove(node)
            println "Identifier exists"
        }

        xml.application[0].appendNode("meta-data", ['android:name': metaDataIdentifier, 'android:value': buildIdentifier])
        def serializeContent = groovy.xml.XmlUtil.serialize(xml)
        new File(manifestFilePath).write(serializeContent)
        println "Modifying manifest file complete!"
    }

    static void uploadMapping(url, uuid, format, mappingFilePath, token, universe, projectName){
        println "Start uploading mapping.."
        url = "${url}post?format=${format}&symbolication_id=${uuid}&token=${token}&universe=${universe}&project=${projectName}"
        println url
        return
        println uuid
        if (mappingFilePath != null && !mappingFilePath.isEmpty()) {
            File file = new File(mappingFilePath)
            println mappingFilePath
            // TODO: Add check if file exists

            def post = new URL(url).openConnection();
            post.setRequestMethod("POST")
            post.setDoOutput(true)
            post.setRequestProperty("Content-Type", "application/json")
            post.getOutputStream().write(file.getBytes())
            println("Sending request..")
            def postRC = post.getResponseCode()
            println("Response..")

            println(postRC);
            if(postRC.equals(200)) {
                println(post.getInputStream().getText());
            }
            else{
                println(post.getErrorStream().getText())
            }
        }
    }

}

//////////////////////////////////////////////////////////////////////////////////////////////////

class Backtrace2Plugin implements Plugin<Project> {
    void apply(Project project) {
        // Add the 'greeting' extension object
        def extension = project.extensions.create('backtrace', BacktracePluginExtension)
        // Add a task that uses configuration from the extension object
        project.task('backtrace') {
            doLast {
                println extension.url
                println extension.token
            }
        }

        project.task('generateBuildIdentifier') {

        }




        project.task('printMappingFile') {
//            def manifest = new XmlSlurper().parse(file("AndroidManifest.xml"))

// returns "com.exmaple.your.app"
//            println manifest.@package.text()
            project.android.applicationVariants.all { variant ->

                // printing the name of each variant
                println variant.name

                // checking for mapping file and printing the absolute path
                if (variant.mappingFile != null && variant.mappingFile.exists()) {
                    println variant.mappingFile.absolutePath
                }
                variant.outputs.each { output ->
//                    def manifestDir = output.processManifest.manifestOutputDirectory
//                    def srcManifestFile = "$manifestDir/AndroidManifest.xml"
                    def buildIdentifier = generateUUID() // TODO: handle passed from parameters

//                    modifyManifestFile(srcManifestFile, buildIdentifier)
//                    TODO: uncomment
                    output.processManifest.doLast {
                        def manifestDir = output.processManifest.manifestOutputDirectory
                        println manifestDir
                        def srcManifestFile = "$manifestDir/AndroidManifest.xml"
                        modifyManifestFile(srcManifestFile, buildIdentifier)
                        println "modifyManifestFile - Done"
                        def url = "https://yolo.sp.backtrace.io:6098/"

                        uploadMapping(url, buildIdentifier, srcManifestFile)
                        println "uploadMapping - Done"
                    }



//                    def processorTask = output.processManifestProvider.getOrNull()
//                    processorTask.doLast { task ->
//                        def directory = task.getBundleManifestOutputDirectory()
//                        println directory
////                        def srcManifestFile = "$directory/AndroidManifest.xml"
////                        def manifestContent = new File(srcManifestFile).getText()
////                        def xml = new XmlParser(false, false).parseText(manifestContent)
////
////                        xml.application[0].appendNode("meta-data", ['android:name': 'channelId', 'android:value': '\\' + channelId])
////
////                        def serializeContent = groovy.xml.XmlUtil.serialize(xml)
////                        def buildType = getPluginBuildType(project)
////                        new File("${project.buildDir}/intermediates/merged_manifests/$buildType/AndroidManifest.xml").write(serializeContent)
//                    }
//                }
                }
            }
        }
    }

    static void modifyManifestFile(String manifestPath, String buildIdentifier){
        println manifestPath
        def metaDataIdentifier = "backtraceBuildIdentifier"
        def manifestContent = new File(manifestPath).getText()
        def xml = new XmlParser(false, false).parseText(manifestContent)

        def buildIdentifierExists = !xml.application[0]["meta-data"]["@android:name=$metaDataIdentifier"].isEmpty()
        if (buildIdentifierExists){ // TODO: add if exists and overwrite
            def node = xml.application[0]["meta-data"].find()
            def parent = node.parent()
            parent.remove(node)
            println "Identifier exists"
        }

        xml.application[0].appendNode("meta-data", ['android:name': metaDataIdentifier, 'android:value': buildIdentifier])
        def serializeContent = xml.XmlUtil.serialize(xml)
        new File(manifestPath).write(serializeContent)
        println "Modifying manifest file complete!"
    }

    static String generateUUID(){
        def id = UUID.randomUUID().toString()
        println "Generated identifier: ${id}"
        return id
    }

    static void uploadMapping(url, uuid, mappingFilePath){
        println "Start uploading mapping.."
//        url = "${url}post?format=android-library&symbolication_id=" + uuid
        def token = 'x'
        url = "${url}post?format=proguard&symbolication_id=${uuid}&token=${token}&universe=yolo&project=android-library"
        println url
        return
        println uuid
            if (mappingFilePath != null && !mappingFilePath.isEmpty()) {
                File file = new File(mappingFilePath)
                println mappingFilePath
                // TODO: Add check if file exists

                def post = new URL(url).openConnection();
                post.setRequestMethod("POST")
                post.setDoOutput(true)
                post.setRequestProperty("Content-Type", "application/json")
                post.getOutputStream().write(file.getBytes())
                println("Sending request..")
                def postRC = post.getResponseCode()
                println("Response..")

                println(postRC);
                if(postRC.equals(200)) {
                    println(post.getInputStream().getText());
                }
                else{
                    println(post.getErrorStream().getText())
                }
            }
    }
}


// Configure the extension

///////////////////////////////////////////////////////


android {
    compileSdkVersion 28
    defaultConfig {
        applicationId "backtraceio.backtraceio"
        minSdkVersion 19
        targetSdkVersion 28
        versionCode 1
        versionName "1.0"
        buildToolsVersion "28.0.2"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
    }
    buildTypes {
        debug {
//            minifyEnabled true
//            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
//            zipAlignEnabled true
        }
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
    buildToolsVersion '28.0.3'
    apply plugin: BacktracePlugin
    backtrace {
        universe = 'yolo'
        projectName = 'android-library'
        format = 'proguard'
        token = '2x'
    }
}

dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    implementation 'com.android.support:appcompat-v7:28.0.0'
    implementation 'com.android.support.constraint:constraint-layout:1.1.3'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:1.0.2'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
    implementation project(':backtrace-library')
}
